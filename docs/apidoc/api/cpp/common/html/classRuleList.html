<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mlrlcommon: RuleList Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mlrlcommon<span id="projectnumber">&#160;0.9.0</span>
   </div>
   <div id="projectbrief">Building-Blocks for Multi-label Rule Learning Algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRuleList-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RuleList Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="rule__list_8hpp_source.html">rule_list.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RuleList:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRuleList.png" usemap="#RuleList_map" alt=""/>
  <map id="RuleList_map" name="RuleList_map">
<area href="classIRuleList.html" alt="IRuleList" shape="rect" coords="0,56,75,80"/>
<area href="classIRuleModel.html" alt="IRuleModel" shape="rect" coords="0,0,75,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList_1_1Rule.html">Rule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a79feb7c6c46cb0f66a00c0cd79f0aa09"><td class="memItemLeft" align="right" valign="top">typedef ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a79feb7c6c46cb0f66a00c0cd79f0aa09">const_iterator</a></td></tr>
<tr class="separator:a79feb7c6c46cb0f66a00c0cd79f0aa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a368596a80408c8767d47cb713de51599"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a368596a80408c8767d47cb713de51599">RuleList</a> (bool defaultRuleTakesPrecedence)</td></tr>
<tr class="separator:a368596a80408c8767d47cb713de51599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4358e77bdedf4ca020f4de5fd4857e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRuleList.html#a79feb7c6c46cb0f66a00c0cd79f0aa09">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a4358e77bdedf4ca020f4de5fd4857e4e">cbegin</a> (uint32 maxRules=0) const</td></tr>
<tr class="separator:a4358e77bdedf4ca020f4de5fd4857e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129a02036551cd090958e0e5e17e18aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRuleList.html#a79feb7c6c46cb0f66a00c0cd79f0aa09">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a129a02036551cd090958e0e5e17e18aa">cend</a> (uint32 maxRules=0) const</td></tr>
<tr class="separator:a129a02036551cd090958e0e5e17e18aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3ff3bed276c2ea33dac775d8cf4627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRuleList.html#a79feb7c6c46cb0f66a00c0cd79f0aa09">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a1f3ff3bed276c2ea33dac775d8cf4627">used_cbegin</a> (uint32 maxRules=0) const</td></tr>
<tr class="separator:a1f3ff3bed276c2ea33dac775d8cf4627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa696f1335ba57bac7d45ed8533a60a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRuleList.html#a79feb7c6c46cb0f66a00c0cd79f0aa09">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#aa696f1335ba57bac7d45ed8533a60a86">used_cend</a> (uint32 maxRules=0) const</td></tr>
<tr class="separator:aa696f1335ba57bac7d45ed8533a60a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac2cc327914a7f4261cb749a9eebfd3"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#adac2cc327914a7f4261cb749a9eebfd3">getNumRules</a> () const override</td></tr>
<tr class="separator:adac2cc327914a7f4261cb749a9eebfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca427bc7fcca654e1eb494b69c94dcd"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#adca427bc7fcca654e1eb494b69c94dcd">getNumUsedRules</a> () const override</td></tr>
<tr class="separator:adca427bc7fcca654e1eb494b69c94dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0b09f75fc1c64e3c3c4142fac3daa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#ace0b09f75fc1c64e3c3c4142fac3daa7">setNumUsedRules</a> (uint32 numUsedRules) override</td></tr>
<tr class="separator:ace0b09f75fc1c64e3c3c4142fac3daa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476dca40ecc153b86edee892af026c24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a476dca40ecc153b86edee892af026c24">addDefaultRule</a> (std::unique_ptr&lt; <a class="el" href="classIHead.html">IHead</a> &gt; headPtr) override</td></tr>
<tr class="separator:a476dca40ecc153b86edee892af026c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd476434d458e00caa57c486207754f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a6fd476434d458e00caa57c486207754f">addRule</a> (std::unique_ptr&lt; <a class="el" href="classIBody.html">IBody</a> &gt; bodyPtr, std::unique_ptr&lt; <a class="el" href="classIHead.html">IHead</a> &gt; headPtr) override</td></tr>
<tr class="separator:a6fd476434d458e00caa57c486207754f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21d72cc8a891f690d52573a2de2f819"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#ad21d72cc8a891f690d52573a2de2f819">containsDefaultRule</a> () const override</td></tr>
<tr class="separator:ad21d72cc8a891f690d52573a2de2f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af817801ba16b7715f8ac202b82acb57a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#af817801ba16b7715f8ac202b82acb57a">isDefaultRuleTakingPrecedence</a> () const override</td></tr>
<tr class="separator:af817801ba16b7715f8ac202b82acb57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515bfd5916810f4449cf6cca4a017575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a515bfd5916810f4449cf6cca4a017575">visit</a> (<a class="el" href="classIBody.html#ac6a02e05dc417dcad240535ceee485fa">IBody::EmptyBodyVisitor</a> emptyBodyVisitor, <a class="el" href="classIBody.html#a479a8c9f0f1ff09c43e6a7f46f8831f9">IBody::ConjunctiveBodyVisitor</a> conjunctiveBodyVisitor, <a class="el" href="classIHead.html#abac84a69689c4f5f0cd43fe3d1401034">IHead::CompleteHeadVisitor</a> completeHeadVisitor, <a class="el" href="classIHead.html#a77aeb6638bc1746e7ca3b67e60c37114">IHead::PartialHeadVisitor</a> partialHeadVisitor) const override</td></tr>
<tr class="separator:a515bfd5916810f4449cf6cca4a017575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2613bc27370823dbc08c8a00e95c527b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a2613bc27370823dbc08c8a00e95c527b">visitUsed</a> (<a class="el" href="classIBody.html#ac6a02e05dc417dcad240535ceee485fa">IBody::EmptyBodyVisitor</a> emptyBodyVisitor, <a class="el" href="classIBody.html#a479a8c9f0f1ff09c43e6a7f46f8831f9">IBody::ConjunctiveBodyVisitor</a> conjunctiveBodyVisitor, <a class="el" href="classIHead.html#abac84a69689c4f5f0cd43fe3d1401034">IHead::CompleteHeadVisitor</a> completeHeadVisitor, <a class="el" href="classIHead.html#a77aeb6638bc1746e7ca3b67e60c37114">IHead::PartialHeadVisitor</a> partialHeadVisitor) const override</td></tr>
<tr class="separator:a2613bc27370823dbc08c8a00e95c527b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7f6d81ab404b09013ebf2e2db44d22"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBinaryPredictor.html">IBinaryPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a3d7f6d81ab404b09013ebf2e2db44d22">createBinaryPredictor</a> (const <a class="el" href="classIBinaryPredictorFactory.html">IBinaryPredictorFactory</a> &amp;factory, const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const override</td></tr>
<tr class="separator:a3d7f6d81ab404b09013ebf2e2db44d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaff30e87a87ea5b9e35283b14288cd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIBinaryPredictor.html">IBinaryPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a5aaff30e87a87ea5b9e35283b14288cd">createBinaryPredictor</a> (const <a class="el" href="classIBinaryPredictorFactory.html">IBinaryPredictorFactory</a> &amp;factory, const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const override</td></tr>
<tr class="separator:a5aaff30e87a87ea5b9e35283b14288cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc30ae94bc9896f39a460d8b8b23d94"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classISparseBinaryPredictor.html">ISparseBinaryPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#adcc30ae94bc9896f39a460d8b8b23d94">createSparseBinaryPredictor</a> (const <a class="el" href="classISparseBinaryPredictorFactory.html">ISparseBinaryPredictorFactory</a> &amp;factory, const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const override</td></tr>
<tr class="separator:adcc30ae94bc9896f39a460d8b8b23d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f48197c5563af85f2d01af89ea52c2c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classISparseBinaryPredictor.html">ISparseBinaryPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a5f48197c5563af85f2d01af89ea52c2c">createSparseBinaryPredictor</a> (const <a class="el" href="classISparseBinaryPredictorFactory.html">ISparseBinaryPredictorFactory</a> &amp;factory, const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const override</td></tr>
<tr class="separator:a5f48197c5563af85f2d01af89ea52c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef83b652954b609e87a6fb7dd85d6e2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIScorePredictor.html">IScorePredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#aeef83b652954b609e87a6fb7dd85d6e2">createScorePredictor</a> (const <a class="el" href="classIScorePredictorFactory.html">IScorePredictorFactory</a> &amp;factory, const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, uint32 numLabels) const override</td></tr>
<tr class="separator:aeef83b652954b609e87a6fb7dd85d6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f6cebe7ea9f01d541faf361858b264"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIScorePredictor.html">IScorePredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a30f6cebe7ea9f01d541faf361858b264">createScorePredictor</a> (const <a class="el" href="classIScorePredictorFactory.html">IScorePredictorFactory</a> &amp;factory, const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, uint32 numLabels) const override</td></tr>
<tr class="separator:a30f6cebe7ea9f01d541faf361858b264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f90fded206236ca10069afb0d6b246d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIProbabilityPredictor.html">IProbabilityPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#a1f90fded206236ca10069afb0d6b246d">createProbabilityPredictor</a> (const <a class="el" href="classIProbabilityPredictorFactory.html">IProbabilityPredictorFactory</a> &amp;factory, const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const override</td></tr>
<tr class="separator:a1f90fded206236ca10069afb0d6b246d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5350da5fca43bb95f1e934f6adf8f16"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classIProbabilityPredictor.html">IProbabilityPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleList.html#ab5350da5fca43bb95f1e934f6adf8f16">createProbabilityPredictor</a> (const <a class="el" href="classIProbabilityPredictorFactory.html">IProbabilityPredictorFactory</a> &amp;factory, const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const override</td></tr>
<tr class="separator:ab5350da5fca43bb95f1e934f6adf8f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf1e9ae149467d4523bcf002d45069f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleList.html#aebf1e9ae149467d4523bcf002d45069f">addDefaultRule</a> (std::unique_ptr&lt; <a class="el" href="classIHead.html">IHead</a> &gt; headPtr)=0</td></tr>
<tr class="separator:aebf1e9ae149467d4523bcf002d45069f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cb4ad3f58d540159dd7af664005054"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleList.html#a33cb4ad3f58d540159dd7af664005054">addRule</a> (std::unique_ptr&lt; <a class="el" href="classIBody.html">IBody</a> &gt; bodyPtr, std::unique_ptr&lt; <a class="el" href="classIHead.html">IHead</a> &gt; headPtr)=0</td></tr>
<tr class="separator:a33cb4ad3f58d540159dd7af664005054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e607246953e75b45779f9787c9a4b55"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleList.html#a0e607246953e75b45779f9787c9a4b55">containsDefaultRule</a> () const =0</td></tr>
<tr class="separator:a0e607246953e75b45779f9787c9a4b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c2619c5d039632c4ab220bd3efc2bf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleList.html#a69c2619c5d039632c4ab220bd3efc2bf">isDefaultRuleTakingPrecedence</a> () const =0</td></tr>
<tr class="separator:a69c2619c5d039632c4ab220bd3efc2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153a4b87c0e19649fea1256cd4bcfec2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleList.html#a153a4b87c0e19649fea1256cd4bcfec2">visit</a> (<a class="el" href="classIBody.html#ac6a02e05dc417dcad240535ceee485fa">IBody::EmptyBodyVisitor</a> emptyBodyVisitor, <a class="el" href="classIBody.html#a479a8c9f0f1ff09c43e6a7f46f8831f9">IBody::ConjunctiveBodyVisitor</a> conjunctiveBodyVisitor, <a class="el" href="classIHead.html#abac84a69689c4f5f0cd43fe3d1401034">IHead::CompleteHeadVisitor</a> completeHeadVisitor, <a class="el" href="classIHead.html#a77aeb6638bc1746e7ca3b67e60c37114">IHead::PartialHeadVisitor</a> partialHeadVisitor) const =0</td></tr>
<tr class="separator:a153a4b87c0e19649fea1256cd4bcfec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ba80c1e9170ef554e10e59c80e55d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleList.html#a00ba80c1e9170ef554e10e59c80e55d5">visitUsed</a> (<a class="el" href="classIBody.html#ac6a02e05dc417dcad240535ceee485fa">IBody::EmptyBodyVisitor</a> emptyBodyVisitor, <a class="el" href="classIBody.html#a479a8c9f0f1ff09c43e6a7f46f8831f9">IBody::ConjunctiveBodyVisitor</a> conjunctiveBodyVisitor, <a class="el" href="classIHead.html#abac84a69689c4f5f0cd43fe3d1401034">IHead::CompleteHeadVisitor</a> completeHeadVisitor, <a class="el" href="classIHead.html#a77aeb6638bc1746e7ca3b67e60c37114">IHead::PartialHeadVisitor</a> partialHeadVisitor) const =0</td></tr>
<tr class="separator:a00ba80c1e9170ef554e10e59c80e55d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e0b6d720b808ec76157ae84dec3ad8"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#ab5e0b6d720b808ec76157ae84dec3ad8">getNumRules</a> () const =0</td></tr>
<tr class="separator:ab5e0b6d720b808ec76157ae84dec3ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b98d45a749d9f1d4ad8f745eaf19ba"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#a38b98d45a749d9f1d4ad8f745eaf19ba">getNumUsedRules</a> () const =0</td></tr>
<tr class="separator:a38b98d45a749d9f1d4ad8f745eaf19ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f99e4f1553c9db05f897fd702ff4765"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#a2f99e4f1553c9db05f897fd702ff4765">setNumUsedRules</a> (uint32 numUsedRules)=0</td></tr>
<tr class="separator:a2f99e4f1553c9db05f897fd702ff4765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95849c35605e8ad2a07eb8466c05d5a"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classIBinaryPredictor.html">IBinaryPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#ae95849c35605e8ad2a07eb8466c05d5a">createBinaryPredictor</a> (const <a class="el" href="classIBinaryPredictorFactory.html">IBinaryPredictorFactory</a> &amp;factory, const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const =0</td></tr>
<tr class="separator:ae95849c35605e8ad2a07eb8466c05d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7dadd54f5599906fa075ff7f02a1b1"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classIBinaryPredictor.html">IBinaryPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#a4b7dadd54f5599906fa075ff7f02a1b1">createBinaryPredictor</a> (const <a class="el" href="classIBinaryPredictorFactory.html">IBinaryPredictorFactory</a> &amp;factory, const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const =0</td></tr>
<tr class="separator:a4b7dadd54f5599906fa075ff7f02a1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1d2af8e99593eba2b55b9a058eccb9"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classISparseBinaryPredictor.html">ISparseBinaryPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#a1c1d2af8e99593eba2b55b9a058eccb9">createSparseBinaryPredictor</a> (const <a class="el" href="classISparseBinaryPredictorFactory.html">ISparseBinaryPredictorFactory</a> &amp;factory, const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const =0</td></tr>
<tr class="separator:a1c1d2af8e99593eba2b55b9a058eccb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8cc480ada53b03a89203634b3c77b1"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classISparseBinaryPredictor.html">ISparseBinaryPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#adb8cc480ada53b03a89203634b3c77b1">createSparseBinaryPredictor</a> (const <a class="el" href="classISparseBinaryPredictorFactory.html">ISparseBinaryPredictorFactory</a> &amp;factory, const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const =0</td></tr>
<tr class="separator:adb8cc480ada53b03a89203634b3c77b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35d6f64903f7e75a20ec5cd0568048f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classIScorePredictor.html">IScorePredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#ae35d6f64903f7e75a20ec5cd0568048f">createScorePredictor</a> (const <a class="el" href="classIScorePredictorFactory.html">IScorePredictorFactory</a> &amp;factory, const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, uint32 numLabels) const =0</td></tr>
<tr class="separator:ae35d6f64903f7e75a20ec5cd0568048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb465e1972502ab1a387088c3c8ceb1"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classIScorePredictor.html">IScorePredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#aaeb465e1972502ab1a387088c3c8ceb1">createScorePredictor</a> (const <a class="el" href="classIScorePredictorFactory.html">IScorePredictorFactory</a> &amp;factory, const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, uint32 numLabels) const =0</td></tr>
<tr class="separator:aaeb465e1972502ab1a387088c3c8ceb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a66fff35e42fcedf66f75186b292b6"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classIProbabilityPredictor.html">IProbabilityPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#a49a66fff35e42fcedf66f75186b292b6">createProbabilityPredictor</a> (const <a class="el" href="classIProbabilityPredictorFactory.html">IProbabilityPredictorFactory</a> &amp;factory, const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const =0</td></tr>
<tr class="separator:a49a66fff35e42fcedf66f75186b292b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15236297faf034078eb5e42fee865bc5"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classIProbabilityPredictor.html">IProbabilityPredictor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRuleModel.html#a15236297faf034078eb5e42fee865bc5">createProbabilityPredictor</a> (const <a class="el" href="classIProbabilityPredictorFactory.html">IProbabilityPredictorFactory</a> &amp;factory, const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;featureMatrix, const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;labelSpaceInfo, const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;marginalProbabilityCalibrationModel, const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;jointProbabilityCalibrationModel, uint32 numLabels) const =0</td></tr>
<tr class="separator:a15236297faf034078eb5e42fee865bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of the type <code><a class="el" href="classIRuleList.html">IRuleList</a></code> that stores several rules in the order of their induction. Optionally, the model may also contain a default rule that either takes precedence over the remaining rules or not. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a79feb7c6c46cb0f66a00c0cd79f0aa09" name="a79feb7c6c46cb0f66a00c0cd79f0aa09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79feb7c6c46cb0f66a00c0cd79f0aa09">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ConstIterator <a class="el" href="classRuleList.html#a79feb7c6c46cb0f66a00c0cd79f0aa09">RuleList::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An iterator that provides read-only access to rules. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a368596a80408c8767d47cb713de51599" name="a368596a80408c8767d47cb713de51599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368596a80408c8767d47cb713de51599">&#9670;&#160;</a></span>RuleList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleList::RuleList </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultRuleTakesPrecedence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultRuleTakesPrecedence</td><td>True, if the default rule should take precedence over the remaining rules, false otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a476dca40ecc153b86edee892af026c24" name="a476dca40ecc153b86edee892af026c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476dca40ecc153b86edee892af026c24">&#9670;&#160;</a></span>addDefaultRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RuleList::addDefaultRule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classIHead.html">IHead</a> &gt;&#160;</td>
          <td class="paramname"><em>headPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new default rule from a given head and adds it to the model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">headPtr</td><td>An unique pointer to an object of type <code><a class="el" href="classIHead.html">IHead</a></code> that should be used as the head of the rule </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIRuleList.html#aebf1e9ae149467d4523bcf002d45069f">IRuleList</a>.</p>

</div>
</div>
<a id="a6fd476434d458e00caa57c486207754f" name="a6fd476434d458e00caa57c486207754f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd476434d458e00caa57c486207754f">&#9670;&#160;</a></span>addRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RuleList::addRule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classIBody.html">IBody</a> &gt;&#160;</td>
          <td class="paramname"><em>bodyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classIHead.html">IHead</a> &gt;&#160;</td>
          <td class="paramname"><em>headPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new rule from a given body and head and adds it to the end of the model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bodyPtr</td><td>An unique pointer to an object of type <code><a class="el" href="classIBody.html">IBody</a></code> that should be used as the body of the rule </td></tr>
    <tr><td class="paramname">headPtr</td><td>An unique pointer to an object of type <code><a class="el" href="classIHead.html">IHead</a></code> that should be used as the head of the rule </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIRuleList.html#a33cb4ad3f58d540159dd7af664005054">IRuleList</a>.</p>

</div>
</div>
<a id="a4358e77bdedf4ca020f4de5fd4857e4e" name="a4358e77bdedf4ca020f4de5fd4857e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4358e77bdedf4ca020f4de5fd4857e4e">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRuleList.html#a79feb7c6c46cb0f66a00c0cd79f0aa09">RuleList::const_iterator</a> RuleList::cbegin </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>maxRules</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <code>const_iterator</code> to the beginning of all rules, including the default rule, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxRules</td><td>The maximum number of rules to consider or 0, if all rules should be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_iterator</code> to the beginning </dd></dl>

</div>
</div>
<a id="a129a02036551cd090958e0e5e17e18aa" name="a129a02036551cd090958e0e5e17e18aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129a02036551cd090958e0e5e17e18aa">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRuleList.html#a79feb7c6c46cb0f66a00c0cd79f0aa09">RuleList::const_iterator</a> RuleList::cend </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>maxRules</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <code>const_iterator</code> to the end of all rules, including the default rule, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxRules</td><td>The maximum number of rules to consider or 0, if all rules should be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_iterator</code> to the end </dd></dl>

</div>
</div>
<a id="ad21d72cc8a891f690d52573a2de2f819" name="ad21d72cc8a891f690d52573a2de2f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21d72cc8a891f690d52573a2de2f819">&#9670;&#160;</a></span>containsDefaultRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RuleList::containsDefaultRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the model contains a default rule or not.</p>
<dl class="section return"><dt>Returns</dt><dd>True, if the model contains a default rule, false otherwise </dd></dl>

<p>Implements <a class="el" href="classIRuleList.html#a0e607246953e75b45779f9787c9a4b55">IRuleList</a>.</p>

</div>
</div>
<a id="a3d7f6d81ab404b09013ebf2e2db44d22" name="a3d7f6d81ab404b09013ebf2e2db44d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7f6d81ab404b09013ebf2e2db44d22">&#9670;&#160;</a></span>createBinaryPredictor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classIBinaryPredictor.html">IBinaryPredictor</a> &gt; RuleList::createBinaryPredictor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBinaryPredictorFactory.html">IBinaryPredictorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>featureMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>labelSpaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>marginalProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>jointProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and returns a new instance of the class <code><a class="el" href="classIBinaryPredictor.html">IBinaryPredictor</a></code>, based on the type of this rule-based model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>A reference to an object of type <code><a class="el" href="classIBinaryPredictorFactory.html">IBinaryPredictorFactory</a></code> that should be used to create the instance </td></tr>
    <tr><td class="paramname">featureMatrix</td><td>A reference to an object of type <code><a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a></code> that provides row-wise access to the features of the query examples </td></tr>
    <tr><td class="paramname">labelSpaceInfo</td><td>A reference to an object of type <code><a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a></code> that provides information about the label space that may be used as a basis for making predictions </td></tr>
    <tr><td class="paramname">marginalProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a></code> that may be used for the calibration of marginal probabilities </td></tr>
    <tr><td class="paramname">jointProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a></code> that may be used for the calibration of joint probabilities </td></tr>
    <tr><td class="paramname">numLabels</td><td>The number of labels to predict for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unique pointer to an object of type <code><a class="el" href="classIBinaryPredictor.html">IBinaryPredictor</a></code> that has been created </dd></dl>

<p>Implements <a class="el" href="classIRuleModel.html#ae95849c35605e8ad2a07eb8466c05d5a">IRuleModel</a>.</p>

</div>
</div>
<a id="a5aaff30e87a87ea5b9e35283b14288cd" name="a5aaff30e87a87ea5b9e35283b14288cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aaff30e87a87ea5b9e35283b14288cd">&#9670;&#160;</a></span>createBinaryPredictor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classIBinaryPredictor.html">IBinaryPredictor</a> &gt; RuleList::createBinaryPredictor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIBinaryPredictorFactory.html">IBinaryPredictorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>featureMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>labelSpaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>marginalProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>jointProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and returns a new instance of the class <code><a class="el" href="classIBinaryPredictor.html">IBinaryPredictor</a></code>, based on the type of this rule-based model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>A reference to an object of type <code><a class="el" href="classIBinaryPredictorFactory.html">IBinaryPredictorFactory</a></code> that should be used to create the instance </td></tr>
    <tr><td class="paramname">featureMatrix</td><td>A reference to an object of type <code><a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a></code> that provides row-wise access to the features of the query examples </td></tr>
    <tr><td class="paramname">labelSpaceInfo</td><td>A reference to an object of type <code><a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a></code> that provides information about the label space that may be used as a basis for making predictions </td></tr>
    <tr><td class="paramname">marginalProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a></code> that may be used for the calibration of marginal probabilities </td></tr>
    <tr><td class="paramname">jointProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a></code> that may be used for the calibration of joint probabilities </td></tr>
    <tr><td class="paramname">numLabels</td><td>The number of labels to predict for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unique pointer to an object of type <code><a class="el" href="classIBinaryPredictor.html">IBinaryPredictor</a></code> that has been created </dd></dl>

<p>Implements <a class="el" href="classIRuleModel.html#a4b7dadd54f5599906fa075ff7f02a1b1">IRuleModel</a>.</p>

</div>
</div>
<a id="a1f90fded206236ca10069afb0d6b246d" name="a1f90fded206236ca10069afb0d6b246d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f90fded206236ca10069afb0d6b246d">&#9670;&#160;</a></span>createProbabilityPredictor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classIProbabilityPredictor.html">IProbabilityPredictor</a> &gt; RuleList::createProbabilityPredictor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIProbabilityPredictorFactory.html">IProbabilityPredictorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>featureMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>labelSpaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>marginalProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>jointProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and returns a new instance of the class <code><a class="el" href="classIProbabilityPredictor.html">IProbabilityPredictor</a></code>, based on the type of this rule-based model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>A reference to an object of type <code><a class="el" href="classIProbabilityPredictorFactory.html">IProbabilityPredictorFactory</a></code> that should be used to create the instance </td></tr>
    <tr><td class="paramname">featureMatrix</td><td>A reference to an object of type <code><a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a></code> that provides row-wise access to the features of the query examples </td></tr>
    <tr><td class="paramname">labelSpaceInfo</td><td>A reference to an object of type <code><a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a></code> that provides information about the label space that may be used as a basis for making predictions </td></tr>
    <tr><td class="paramname">marginalProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a></code> that may be used for the calibration of marginal probabilities </td></tr>
    <tr><td class="paramname">jointProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a></code> that may be used for the calibration of joint probabilities </td></tr>
    <tr><td class="paramname">numLabels</td><td>The number of labels to predict for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unique pointer to an object of type <code><a class="el" href="classIProbabilityPredictor.html">IProbabilityPredictor</a></code> that has been created </dd></dl>

<p>Implements <a class="el" href="classIRuleModel.html#a49a66fff35e42fcedf66f75186b292b6">IRuleModel</a>.</p>

</div>
</div>
<a id="ab5350da5fca43bb95f1e934f6adf8f16" name="ab5350da5fca43bb95f1e934f6adf8f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5350da5fca43bb95f1e934f6adf8f16">&#9670;&#160;</a></span>createProbabilityPredictor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classIProbabilityPredictor.html">IProbabilityPredictor</a> &gt; RuleList::createProbabilityPredictor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIProbabilityPredictorFactory.html">IProbabilityPredictorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>featureMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>labelSpaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>marginalProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>jointProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and returns a new instance of the class <code><a class="el" href="classIProbabilityPredictor.html">IProbabilityPredictor</a></code>, based on the type of this rule-based model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>A reference to an object of type <code><a class="el" href="classIProbabilityPredictorFactory.html">IProbabilityPredictorFactory</a></code> that should be used to create the instance </td></tr>
    <tr><td class="paramname">featureMatrix</td><td>A reference to an object of type <code><a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a></code> that provides row-wise access to the features of the query examples </td></tr>
    <tr><td class="paramname">labelSpaceInfo</td><td>A reference to an object of type <code><a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a></code> that provides information about the label space that may be used as a basis for making predictions </td></tr>
    <tr><td class="paramname">marginalProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a></code> that may be used for the calibration of marginal probabilities </td></tr>
    <tr><td class="paramname">jointProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a></code> that may be used for the calibration of joint probabilities </td></tr>
    <tr><td class="paramname">numLabels</td><td>The number of labels to predict for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unique pointer to an object of type <code><a class="el" href="classIProbabilityPredictor.html">IProbabilityPredictor</a></code> that has been created </dd></dl>

<p>Implements <a class="el" href="classIRuleModel.html#a15236297faf034078eb5e42fee865bc5">IRuleModel</a>.</p>

</div>
</div>
<a id="aeef83b652954b609e87a6fb7dd85d6e2" name="aeef83b652954b609e87a6fb7dd85d6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef83b652954b609e87a6fb7dd85d6e2">&#9670;&#160;</a></span>createScorePredictor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classIScorePredictor.html">IScorePredictor</a> &gt; RuleList::createScorePredictor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIScorePredictorFactory.html">IScorePredictorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>featureMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>labelSpaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and returns a new instance of the class <code><a class="el" href="classIScorePredictor.html">IScorePredictor</a></code>, based on the type of this rule-based model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>A reference to an object of type <code><a class="el" href="classIScorePredictorFactory.html">IScorePredictorFactory</a></code> that should be used to create the instance </td></tr>
    <tr><td class="paramname">featureMatrix</td><td>A reference to an object of type <code><a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a></code> that provides row-wise access to the features of the query examples </td></tr>
    <tr><td class="paramname">labelSpaceInfo</td><td>A reference to an object of type <code><a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a></code> that provides information about the label space that may be used as a basis for making predictions </td></tr>
    <tr><td class="paramname">numLabels</td><td>The number of labels to predict for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unique pointer to an object of type <code><a class="el" href="classIScorePredictor.html">IScorePredictor</a></code> that has been created </dd></dl>

<p>Implements <a class="el" href="classIRuleModel.html#ae35d6f64903f7e75a20ec5cd0568048f">IRuleModel</a>.</p>

</div>
</div>
<a id="a30f6cebe7ea9f01d541faf361858b264" name="a30f6cebe7ea9f01d541faf361858b264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f6cebe7ea9f01d541faf361858b264">&#9670;&#160;</a></span>createScorePredictor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classIScorePredictor.html">IScorePredictor</a> &gt; RuleList::createScorePredictor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIScorePredictorFactory.html">IScorePredictorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>featureMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>labelSpaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and returns a new instance of the class <code><a class="el" href="classIScorePredictor.html">IScorePredictor</a></code>, based on the type of this rule-based model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>A reference to an object of type <code><a class="el" href="classIScorePredictorFactory.html">IScorePredictorFactory</a></code> that should be used to create the instance </td></tr>
    <tr><td class="paramname">featureMatrix</td><td>A reference to an object of type <code><a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a></code> that provides row-wise access to the features of the query examples </td></tr>
    <tr><td class="paramname">labelSpaceInfo</td><td>A reference to an object of type <code><a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a></code> that provides information about the label space that may be used as a basis for making predictions </td></tr>
    <tr><td class="paramname">numLabels</td><td>The number of labels to predict for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unique pointer to an object of type <code><a class="el" href="classIScorePredictor.html">IScorePredictor</a></code> that has been created </dd></dl>

<p>Implements <a class="el" href="classIRuleModel.html#aaeb465e1972502ab1a387088c3c8ceb1">IRuleModel</a>.</p>

</div>
</div>
<a id="adcc30ae94bc9896f39a460d8b8b23d94" name="adcc30ae94bc9896f39a460d8b8b23d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc30ae94bc9896f39a460d8b8b23d94">&#9670;&#160;</a></span>createSparseBinaryPredictor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classISparseBinaryPredictor.html">ISparseBinaryPredictor</a> &gt; RuleList::createSparseBinaryPredictor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classISparseBinaryPredictorFactory.html">ISparseBinaryPredictorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>featureMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>labelSpaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>marginalProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>jointProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and returns a new instance of the class <code><a class="el" href="classISparseBinaryPredictor.html">ISparseBinaryPredictor</a></code>, based on the type of this rule-based model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>A reference to an object of type <code><a class="el" href="classIBinaryPredictorFactory.html">IBinaryPredictorFactory</a></code> that should be used to create the instance </td></tr>
    <tr><td class="paramname">featureMatrix</td><td>A reference to an object of type <code><a class="el" href="classCContiguousFeatureMatrix.html">CContiguousFeatureMatrix</a></code> that provides row-wise access to the features of the query examples </td></tr>
    <tr><td class="paramname">labelSpaceInfo</td><td>A reference to an object of type <code><a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a></code> that provides information about the label space that may be used as a basis for making predictions </td></tr>
    <tr><td class="paramname">marginalProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a></code> that may be used for the calibration of marginal probabilities </td></tr>
    <tr><td class="paramname">jointProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a></code> that may be used for the calibration of joint probabilities </td></tr>
    <tr><td class="paramname">numLabels</td><td>The number of labels to predict for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unique pointer to an object of type <code><a class="el" href="classISparseBinaryPredictor.html">ISparseBinaryPredictor</a></code> that has been created </dd></dl>

<p>Implements <a class="el" href="classIRuleModel.html#a1c1d2af8e99593eba2b55b9a058eccb9">IRuleModel</a>.</p>

</div>
</div>
<a id="a5f48197c5563af85f2d01af89ea52c2c" name="a5f48197c5563af85f2d01af89ea52c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f48197c5563af85f2d01af89ea52c2c">&#9670;&#160;</a></span>createSparseBinaryPredictor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classISparseBinaryPredictor.html">ISparseBinaryPredictor</a> &gt; RuleList::createSparseBinaryPredictor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classISparseBinaryPredictorFactory.html">ISparseBinaryPredictorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>featureMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>labelSpaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>marginalProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a> &amp;&#160;</td>
          <td class="paramname"><em>jointProbabilityCalibrationModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and returns a new instance of the class <code><a class="el" href="classISparseBinaryPredictor.html">ISparseBinaryPredictor</a></code>, based on the type of this rule-based model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>A reference to an object of type <code><a class="el" href="classIBinaryPredictorFactory.html">IBinaryPredictorFactory</a></code> that should be used to create the instance </td></tr>
    <tr><td class="paramname">featureMatrix</td><td>A reference to an object of type <code><a class="el" href="classCsrFeatureMatrix.html">CsrFeatureMatrix</a></code> that provides row-wise access to the features of the query examples </td></tr>
    <tr><td class="paramname">labelSpaceInfo</td><td>A reference to an object of type <code><a class="el" href="classILabelSpaceInfo.html">ILabelSpaceInfo</a></code> that provides information about the label space that may be used as a basis for making predictions </td></tr>
    <tr><td class="paramname">marginalProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIMarginalProbabilityCalibrationModel.html">IMarginalProbabilityCalibrationModel</a></code> that may be used for the calibration of marginal probabilities </td></tr>
    <tr><td class="paramname">jointProbabilityCalibrationModel</td><td>A reference to an object of type <code><a class="el" href="classIJointProbabilityCalibrationModel.html">IJointProbabilityCalibrationModel</a></code> that may be used for the calibration of joint probabilities </td></tr>
    <tr><td class="paramname">numLabels</td><td>The number of labels to predict for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unique pointer to an object of type <code><a class="el" href="classISparseBinaryPredictor.html">ISparseBinaryPredictor</a></code> that has been created </dd></dl>

<p>Implements <a class="el" href="classIRuleModel.html#adb8cc480ada53b03a89203634b3c77b1">IRuleModel</a>.</p>

</div>
</div>
<a id="adac2cc327914a7f4261cb749a9eebfd3" name="adac2cc327914a7f4261cb749a9eebfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac2cc327914a7f4261cb749a9eebfd3">&#9670;&#160;</a></span>getNumRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 RuleList::getNumRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the total number of rules in the model, including the default rule, if available.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of rules </dd></dl>

<p>Implements <a class="el" href="classIRuleModel.html#ab5e0b6d720b808ec76157ae84dec3ad8">IRuleModel</a>.</p>

</div>
</div>
<a id="adca427bc7fcca654e1eb494b69c94dcd" name="adca427bc7fcca654e1eb494b69c94dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca427bc7fcca654e1eb494b69c94dcd">&#9670;&#160;</a></span>getNumUsedRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 RuleList::getNumUsedRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of used rules, including the default rule, if available.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of used rules </dd></dl>

<p>Implements <a class="el" href="classIRuleModel.html#a38b98d45a749d9f1d4ad8f745eaf19ba">IRuleModel</a>.</p>

</div>
</div>
<a id="af817801ba16b7715f8ac202b82acb57a" name="af817801ba16b7715f8ac202b82acb57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af817801ba16b7715f8ac202b82acb57a">&#9670;&#160;</a></span>isDefaultRuleTakingPrecedence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RuleList::isDefaultRuleTakingPrecedence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the default rule takes precedence over the remaining rules or not.</p>
<dl class="section return"><dt>Returns</dt><dd>True, if the default rule takes precedence over the remaining rules, false otherwise </dd></dl>

<p>Implements <a class="el" href="classIRuleList.html#a69c2619c5d039632c4ab220bd3efc2bf">IRuleList</a>.</p>

</div>
</div>
<a id="ace0b09f75fc1c64e3c3c4142fac3daa7" name="ace0b09f75fc1c64e3c3c4142fac3daa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0b09f75fc1c64e3c3c4142fac3daa7">&#9670;&#160;</a></span>setNumUsedRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RuleList::setNumUsedRules </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numUsedRules</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the number of used rules, including the default rule, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numUsedRules</td><td>The number of used rules to be set or 0, if all rules should be used </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIRuleModel.html#a2f99e4f1553c9db05f897fd702ff4765">IRuleModel</a>.</p>

</div>
</div>
<a id="a1f3ff3bed276c2ea33dac775d8cf4627" name="a1f3ff3bed276c2ea33dac775d8cf4627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3ff3bed276c2ea33dac775d8cf4627">&#9670;&#160;</a></span>used_cbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRuleList.html#a79feb7c6c46cb0f66a00c0cd79f0aa09">RuleList::const_iterator</a> RuleList::used_cbegin </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>maxRules</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <code>const_iterator</code> to the beginning of all used rules, including the default rule, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxRules</td><td>The maximum number of rules to consider or 0, if all rules should be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_iterator</code> to the beginning </dd></dl>

</div>
</div>
<a id="aa696f1335ba57bac7d45ed8533a60a86" name="aa696f1335ba57bac7d45ed8533a60a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa696f1335ba57bac7d45ed8533a60a86">&#9670;&#160;</a></span>used_cend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRuleList.html#a79feb7c6c46cb0f66a00c0cd79f0aa09">RuleList::const_iterator</a> RuleList::used_cend </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>maxRules</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <code>const_iterator</code> to the end of all used rules, including the default rule, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxRules</td><td>The maximum number of rules to consider or 0, if all used rules should be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const_iterator</code> to the end </dd></dl>

</div>
</div>
<a id="a515bfd5916810f4449cf6cca4a017575" name="a515bfd5916810f4449cf6cca4a017575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515bfd5916810f4449cf6cca4a017575">&#9670;&#160;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RuleList::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBody.html#ac6a02e05dc417dcad240535ceee485fa">IBody::EmptyBodyVisitor</a>&#160;</td>
          <td class="paramname"><em>emptyBodyVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBody.html#a479a8c9f0f1ff09c43e6a7f46f8831f9">IBody::ConjunctiveBodyVisitor</a>&#160;</td>
          <td class="paramname"><em>conjunctiveBodyVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIHead.html#abac84a69689c4f5f0cd43fe3d1401034">IHead::CompleteHeadVisitor</a>&#160;</td>
          <td class="paramname"><em>completeHeadVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIHead.html#a77aeb6638bc1746e7ca3b67e60c37114">IHead::PartialHeadVisitor</a>&#160;</td>
          <td class="paramname"><em>partialHeadVisitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invokes some of the given visitor functions, depending on which ones are able to handle the bodies and heads of all rules that are contained in this model, including the default rule, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">emptyBodyVisitor</td><td>The visitor function for handling objects of the type <code><a class="el" href="classEmptyBody.html">EmptyBody</a></code> </td></tr>
    <tr><td class="paramname">conjunctiveBodyVisitor</td><td>The visitor function for handling objects of the type <code><a class="el" href="classConjunctiveBody.html">ConjunctiveBody</a></code> </td></tr>
    <tr><td class="paramname">completeHeadVisitor</td><td>The visitor function for handling objects of the type <code><a class="el" href="classCompleteHead.html">CompleteHead</a></code> </td></tr>
    <tr><td class="paramname">partialHeadVisitor</td><td>The visitor function for handling objects of the type <code><a class="el" href="classPartialHead.html">PartialHead</a></code> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIRuleList.html#a153a4b87c0e19649fea1256cd4bcfec2">IRuleList</a>.</p>

</div>
</div>
<a id="a2613bc27370823dbc08c8a00e95c527b" name="a2613bc27370823dbc08c8a00e95c527b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2613bc27370823dbc08c8a00e95c527b">&#9670;&#160;</a></span>visitUsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RuleList::visitUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIBody.html#ac6a02e05dc417dcad240535ceee485fa">IBody::EmptyBodyVisitor</a>&#160;</td>
          <td class="paramname"><em>emptyBodyVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIBody.html#a479a8c9f0f1ff09c43e6a7f46f8831f9">IBody::ConjunctiveBodyVisitor</a>&#160;</td>
          <td class="paramname"><em>conjunctiveBodyVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIHead.html#abac84a69689c4f5f0cd43fe3d1401034">IHead::CompleteHeadVisitor</a>&#160;</td>
          <td class="paramname"><em>completeHeadVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIHead.html#a77aeb6638bc1746e7ca3b67e60c37114">IHead::PartialHeadVisitor</a>&#160;</td>
          <td class="paramname"><em>partialHeadVisitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invokes some of the given visitor functions, depending on which ones are able to handle the bodies and heads of all used rules that are contained in this model, including the default rule, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">emptyBodyVisitor</td><td>The visitor function for handling objects of the type <code><a class="el" href="classEmptyBody.html">EmptyBody</a></code> </td></tr>
    <tr><td class="paramname">conjunctiveBodyVisitor</td><td>The visitor function for handling objects of the type <code><a class="el" href="classConjunctiveBody.html">ConjunctiveBody</a></code> </td></tr>
    <tr><td class="paramname">completeHeadVisitor</td><td>The visitor function for handling objects of the type <code><a class="el" href="classCompleteHead.html">CompleteHead</a></code> </td></tr>
    <tr><td class="paramname">partialHeadVisitor</td><td>The visitor function for handling objects of the type <code><a class="el" href="classPartialHead.html">PartialHead</a></code> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIRuleList.html#a00ba80c1e9170ef554e10e59c80e55d5">IRuleList</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="rule__list_8hpp_source.html">rule_list.hpp</a></li>
<li>rule_list.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
